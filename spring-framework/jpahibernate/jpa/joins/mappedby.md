‚è∫Ô∏è ‚û°Ô∏è üü¶ üîµ üü¢üî¥‚≠ïüü†üü£üü•üüß‚úîÔ∏è ‚òëÔ∏è ‚Ä¢ ‚Ä£ ‚Üí ‚Åï

# ‚è∫Ô∏è mappedBy ‚Äî Inverse Side of the Relationship

- **mappedBy** tells JPA that the current entity is not the owner of the relationship. The ownership lies with
  the other side (where `@JoinColumn` or `@JoinTable` is defined).
- Typically on the inverse (non-owning) side of a bidirectional relationship.
- Prevents JPA from creating an unnecessary extra join table or column.

### Bidirectional Relationships Only

- Keeps bidirectional mapping in sync.
- @MappedBy is not used in unidirectional relationships because there's no "other side" to map to.
- It's typically paired with:
  - @OneToMany(mappedBy = "fieldName") (e.g., a parent entity like Order mapping to children like OrderItem).
  - @ManyToMany(mappedBy = "fieldName") (e.g., in a join table scenario).
  - Less commonly, @OneToOne(mappedBy = "fieldName").
- **Syntax:** `@MappedBy("fieldName")`, where fieldName is the exact name of the field on the owning side that holds the reference back to this entity.

##### üîµ Owning Side: Order Entity

- The Order owns the relationship by defining the FK.

```java
 import jakarta.persistence.*;
import java.time.LocalDate;
import java.util.UUID;

@Entity
@Table(name = "orders")
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String orderNumber;  // e.g., "ORD-123"

    private LocalDate orderDate;

    // Owning side: This field holds the reference to Customer.
    // Defines the FK 'customer_id' in the orders table.
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "customer_id", nullable = false)  // Explicit FK column; not null for integrity
    private Customer customer;  // <-- This is the "fieldName": "customer"

    // Constructors
    public Order() {}
    public Order(String orderNumber, LocalDate orderDate, Customer customer) {
        this.orderNumber = orderNumber;
        this.orderDate = orderDate;
        this.customer = customer;
    }

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getOrderNumber() { return orderNumber; }
    public void setOrderNumber(String orderNumber) { this.orderNumber = orderNumber; }
    public LocalDate getOrderDate() { return orderDate; }
    public void setOrderDate(LocalDate orderDate) { this.orderDate = orderDate; }
    public Customer getCustomer() { return customer; }
    public void setCustomer(Customer customer) { this.customer = customer; }
}
```

##### üîµ Inverse Side: Customer Entity

- The Customer is inverse‚Äîno FK column added to its table. @MappedBy points to the owning field's name.

```java
  import jakarta.persistence.*;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Inverse side: Collection of orders, mapped by the 'customer' field in Order.
    @OneToMany(mappedBy = "customer", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)
    //                           ^^^^^^^^^^ <-- "customer" exactly matches the field name in Order
    private List<Order> orders = new ArrayList<>();

    // Helper method to add an order and sync both sides (prevents inconsistencies)
    public void addOrder(Order order) {
        orders.add(order);
        order.setCustomer(this);  // Sync owning side
    }

    // Helper method to remove an order
    public void removeOrder(Order order) {
        orders.remove(order);
        order.setCustomer(null);  // Sync owning side
    }

    // Constructors
    public Customer() {}
    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }

    // Getters and setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public List<Order> getOrders() { return orders; }
    public void setOrders(List<Order> orders) { this.orders = orders; }
}
```

##### üîµ Database Schema Generated by JPA

- **customers table:**
  | Column | Description |
  | --------- | -------------- |
  | `id` (PK) | Primary key |
  | `name` | Customer name |
  | `email` | Customer email |

```java
  CREATE TABLE customers (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);

```

- **orders table:**
  | Column | Description |
  | ------------------ | ------------------------------------ |
  | `id` (PK) | Primary key of Order |
  | `order_number` | Order reference number |
  | `order_date` | Date of the order |
  | `customer_id` (FK) | Foreign key ‚Üí customers.id, NOT NULL |

```java
CREATE TABLE orders (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    order_number VARCHAR(50) NOT NULL,
    order_date DATE,
    customer_id BIGINT NOT NULL,
    CONSTRAINT fk_customer FOREIGN KEY (customer_id)
        REFERENCES customers(id)
);

```

- **@MappedBy("customer")** ensures no redundant FK (e.g., no `order_id` in customers).

##### üîµ Controller

```java
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class OrderController {

    @Autowired
    private OrderService orderService;

    @PostMapping("/customers")
    public Customer createCustomer() {
        return orderService.createCustomerWithOrders();
    }

    @GetMapping("/customers/{id}")
    public Customer getCustomer(@PathVariable Long id) {
        return orderService.getCustomerWithOrders(id);
    }
}
```

##### üîµ Service

```java
  import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
@Transactional  // Handles transactions across repo calls
public class OrderService {

    @Autowired  // Or use constructor injection (preferred)
    private CustomerRepository customerRepository;

    @Autowired
    private OrderRepository orderRepository;

    // Create customer with orders (cascading happens via entity annotations)
    public Customer createCustomerWithOrders() {
        Customer customer = new Customer("John Doe", "john@example.com");

        Order order1 = new Order("ORD-001", LocalDate.now(), customer);  // Set owning side directly
        Order order2 = new Order("ORD-002", LocalDate.now().plusDays(1), customer);

        // Sync inverse side using helper
        customer.addOrder(order1);
        customer.addOrder(order2);

        // Save: Repos handle persist/merge + cascade
        return customerRepository.save(customer);  // Auto-saves orders via cascade
    }

    // Query and navigate (uses repo methods)
    public Customer getCustomerWithOrders(Long customerId) {
        Optional<Customer> optionalCustomer = customerRepository.findById(customerId);
        if (optionalCustomer.isPresent()) {
            Customer customer = optionalCustomer.get();
            // Accessing customer.getOrders() triggers lazy load (or use @EntityGraph for eager)
            System.out.println("Customer: " + customer.getName());
            System.out.println("Number of orders: " + customer.getOrders().size());
            return customer;
        }
        throw new RuntimeException("Customer not found");
    }

    // Navigate from order back to customer
    public void getOrderDetails(Long orderId) {
        Optional<Order> optionalOrder = orderRepository.findByIdWithCustomer(orderId);  // Uses custom query
        optionalOrder.ifPresent(order -> {
            System.out.println("Order: " + order.getOrderNumber());
            System.out.println("Belongs to: " + order.getCustomer().getName());
        });
    }

    // Update relationship (e.g., remove order)
    public void removeOrderFromCustomer(Long customerId, Long orderId) {
        Customer customer = customerRepository.findById(customerId)
            .orElseThrow(() -> new RuntimeException("Customer not found"));

        Optional<Order> optionalOrder = orderRepository.findById(orderId);
        optionalOrder.ifPresent(order -> {
            // Sync and remove
            customer.removeOrder(order);
            // Save triggers orphanRemoval delete
            customerRepository.save(customer);
        });
    }

    // Example: Custom query across entities
    public List<Order> getRecentOrdersForCustomer(String email) {
        Optional<Customer> customer = customerRepository.findByEmail(email);
        return customer.map(cust ->
            orderRepository.findByOrderDateBetween(LocalDate.now().minusDays(30), LocalDate.now())
        ).orElse(List.of());
    }
}
```

##### üîµ Repository Interfaces

```java
  import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

// CustomerRepository
@Repository
public interface CustomerRepository extends JpaRepository<Customer, Long> {
    // Custom query methods (auto-implemented)
    Optional<Customer> findByEmail(String email);
    List<Customer> findByNameContainingIgnoreCase(String name);
}

// OrderRepository
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    // Example custom finder
    List<Order> findByOrderDateBetween(LocalDate start, LocalDate end);
    @Query("SELECT o FROM Order o JOIN FETCH o.customer WHERE o.id = :id")  // Eager fetch to avoid N+1
    Optional<Order> findByIdWithCustomer(@Param("id") Long id);
}
```
